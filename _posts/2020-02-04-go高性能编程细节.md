---
layout: post
title: '浅谈GO性能优化'
date: 2020-02-04
author: blossom
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: go pprof
---

> 日常工作编码过程中如何注意代码细节，保证写出高性能的代码

### 基础
编程高性能的go程序，除了利用轻量级协程提升程序性能，我们还应该注意一些细节，这样有助于我们提升代码质量以及执行效率。在我们发现自己的系统模块是可优化的时候，应该尽量花时间去优化，如果每次都内心想：‘下次在优化’，那么当它真正臃肿的时候，我们将会无力去优化。
<br>当然在性能方面，过早优化时万恶之源，当我们的系统并没有遇到真正的瓶颈时，我们不需要花太多时间去提高性能。

### 编码细节
#### 内存复用
关于内存复用最常见的手段就是内存池了，它缓存已分配但不再使用的对象，在下次分配时进行复用，以避免频繁的对象分配，减少gc压力。
<br>GO官方提供了sync.Pool来进行对象的存储，我们可以看下官方fmt包对sync.Pool的使用：

    // pp is used to store a printer's state and is reused with sync.Pool to avoid allocations.
    type pp struct {
    	buf buffer
    	.... 省略
    }
    var ppFree = sync.Pool{
    	New: func() interface{} { return new(pp) },
    }
    // newPrinter allocates a new pp struct or grabs a cached one.
    func newPrinter() *pp {
    	p := ppFree.Get().(*pp)
        ... 省略
    	p.fmt.init(&p.buf)
    	return p
    }
    #每当我们每次调用fmt的函数时候，比如fmt.Errorf，都会newPrinter
    func Errorf(format string, a ...interface{}) error {
    	p := newPrinter() #new
        .... 省略
    	p.free() #释放对象的值
    	return err
    }
    
sync.Pool不能设置内存池的大小，他的容量取决于内存大小，如果get不到对象，那么就会调用New定义的func重新创建一个新的对象，而且为了防止sync.Pool无限增大，它是会被定期GC的，
所以并不适合用来存放连接这类对象。


#### 序列化问题
go原生json序列化时采用反射机制进行序列化和反序列化，对于高并发情况下，会有性能问题。
<br>对于已知的数据结构，知道如何序列化和反序列化的化，还是不要用原生的json序列化或者可以使用andyleap/gencode工具序列化，提高性能。

#### defer关键字
go.1.14版本以前defer的性能比较差，这个和defer的原理有关系，但是再defer1.14版本

