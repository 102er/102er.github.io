---
layout: post
title: '浅谈GO性能优化'
date: 2020-02-04
author: blossom
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: go pprof
---

> 日常工作编码过程中如何注意代码细节，保证写出高性能的代码

### 基础
编程高性能的go程序，除了利用轻量级协程提升程序性能，我们还应该注意一些细节，这样有助于我们提升代码质量以及执行效率。
<br>日常工作中，我们发现自己的系统模块是可优化的时候，应该尽量花时间去优化，如果每次都内心想：‘下次在优化’，那么当它真正臃肿的时候，我们将会无力去优化。
<br>在性能方面，过早优化时万恶之源，当我们的系统并没有遇到真正的瓶颈时，我们不需要花太多时间去提高性能。

### 编码细节
#### 内存复用
关于内存复用最常见的手段就是内存池了，它缓存已分配但不再使用的对象，在下次分配时进行复用，以避免频繁的对象分配，减少gc压力。
<br>GO官方提供了sync.Pool来进行对象的存储，我们可以看下官方fmt包对sync.Pool的使用：

    // pp is used to store a printer's state and is reused with sync.Pool to avoid allocations.
    type pp struct {
    	buf buffer
    	.... 省略
    }
    
    var ppFree = sync.Pool{
    	New: func() interface{} { return new(pp) },
    }
    
    // newPrinter allocates a new pp struct or grabs a cached one.
    func newPrinter() *pp {
    	p := ppFree.Get().(*pp)
    	p.panicking = false
    	p.erroring = false
    	p.wrapErrs = false
    	p.fmt.init(&p.buf)
    	return p
    }
    #每当我们每次调用fmt的函数时候，比如fmt.Errorf，都会newPrinter
    func Errorf(format string, a ...interface{}) error {
    	p := newPrinter() #new
        .... 省略
    	p.free() #对象的值
    	return err
    }
    
sync.Pool不能设置内存池的大小，如果get不到对象，那么就会调用New定义的func重新创建一个新的对象，而且为了防止sync.Pool无限增大，它是会被定期GC的，
所以并不适合用来存放连接这类对象。


