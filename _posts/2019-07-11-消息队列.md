---
layout: post
title: '消息队列组件'
date: 2019-07-11
author: blossom
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: kafka rabbitMq 消息队列
---

> 消息队列，比较kafka和rabbitMQ的差异

### 基础
消息队列中间件是通过高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统集成。通过提供消息传递和消息排队模型，可以在分布式环境
下实现应用解耦，异步通信，数据同步,限流/削峰等功能。
#### 什么是消息队列
消息队列（message queue）消息即数据信息，队列即一种先进先出的数据结构，组合一起：把需要传输的数据放进队列中。<br>
生产者：把数据消息放进队列；<br>
消费者：把数据消息从队列中读取出来；
#### 特点
* 异步处理模式，消息发送者无须等待响应，只要按照特定主题把消息推送到队列，而消息接收者只需订阅或者监听某个主题消息通道，。整个过程都是异步的。
* 解耦，不同组件通过消息中间件，进行业务解耦，这样可以避免某个流程崩溃导致整个业务崩溃。
* 限流，数据请求放消息队列，由消费者主动去读取消息，pull的当时可以避免业务处理系统压力过大。
#### 模式
* 点对点的模式，生产者把消息投递到queue中，消费者从queue中读取消息，成功接收消息后像队列应答，此时队列将会删除这条消息，所以一个消息只能被读取一次；
* 发布/订阅模式，生产者把消息投递到topic，系统将会把这些消息传递给订阅方；

### Kafka
基于zk协调的分布式发布订阅消息系统，主要应用场景是日志收集系统和消息系统。
具备高吞吐率，内置分区，支持数据副本，快速持久化，自动实现负载均衡。

![kafka架构图](https://blossom102er.github.io/assets/img/kafka.png)

####特性
* 高吞吐量：吞吐量高达数十万
* 高并发：支持数千个客户端同时读写
* 低延迟：延迟最低只有几毫秒
* 消息持久性和可靠性：消息被持久化到本地磁盘，同时支持数据备份
* 集群容错性：允许n-1个节点失败（n为副本个数）
* 可扩展性：支持集群动态扩展

#### 名称解释
* Topic：在Kafka中，使用一个类别属性来划分数据的所属类，划分数据的这个类称为topic。如果把Kafka看做为一个数据库，topic可以理解为数据库中的一张表，topic的名字即为表名。
* Partition：topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。
* Partition offset：每条消息都有一个当前Partition下唯一的64字节的offset，它指明了这条消息的起始位置。
* Replicas of partition：副本是一个分区的备份。副本不会被消费者消费，副本只用于防止数据丢失，即消费者不从为follower的partition中消费数据，而是从为leader的partition中读取数据。
* Broker：Kafka 集群包含一个或多个服务器，服务器节点称为broker。<br> broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。
<br>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。
<br>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。
* Producer：生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。
* Consumer：消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。
* Leader：每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。
* Follower：Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。

### rabbitMQ
基于amqp（Advanced Message Queuing Protocol）实现的高级消息队列协议。
![rabbitmq架构图](https://blossom102er.github.io/assets/img/rabbit_mq.png)
#### 特性
* 可靠性，支持消息持久，投递确认，发布者证实，高可用等机制；
* 灵活路由，提供exchange来路由消息，可以支持绑定多个exchange；
* 消息集群 多个rabbitmq可以组成一个逻辑的 broker
* 高可用 队列可以在集群中的机器进行镜像，部分节点出问题，不会影响整个队列使用
* 多语言客户端 几乎支持所有常用语言客户端
* 提供管理界面，可以管理和监控消息队列
* 跟踪机制 提供消息追踪机制，使用者可以追溯消息的生命周期
#### 名词解释
    - Message 消息，由消息头和消息体组成，消息头由：routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等组成；
    - Publisher 消息生产者 、
    - Exchange 交换机，接收生产者投递的消息并把消息路由给队列
    - Routing key 路由关键字 exchange根据关键字进行消息投递，也就是用于把生产的消息分配到交换机上。
    - Binding key 绑定，用于消息队列和交换机之间的关联。一个绑定是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换机理解成一个由绑定构成的路由表
    - Queue 消息队列 用来保存消息，直到消息被消费，消息容器
    - Channel 信道
    - Consumer 消费者 ，从消息队列读取消息
    - Virtual host 虚拟主机 表示一批交换器、消息队列和相关对象。每个虚拟机主机都是独立的
    - broker 接收和分发消息的应用，消息队列服务器的实体，保证数据能够按照指定的方式进行传输。

