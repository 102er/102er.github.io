---
layout: post
title: '链表以及go中链表的实现'
date: 2020-01-19
author: blossom
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: go 链表 数据结构
---

> 了解链表数据结构，以及go中的运用

### 基础
#### 1.1 什么是链表
* 由一组不必相连的内存结构，按特定顺序链接在一起的抽象数据类型；
* 其中线性顺序不是由他们在内存中的物理位置所给出；
* 不需要按顺序存储，链表插入数据的时间复杂度O(1)，但是查询需要O(n)；
* 实现了内存动态管理，但因为需要存储节点指针，空间开销大一点。

#### 1.1 链表分类
* 单向链表：各个内存结构由一个next指针链接在一起，内存结构由数据域和Next指针域组成，链尾指向Null。查找数据，只能从头查到尾，顺序查找。<br>
通俗理解就是: A B C三个人，A知道B的卧底，B知道C的卧底，这样就组成了一个单向链表结构了。
![单链表](https://blossom102er.github.io/assets/img/only-list.jpg)

* 双向链表：就是单链表的改进，内存结构由数据域，指针Next和指针prev组成。这种可以有效解决，单链表在某个节点需要前驱操作时，只能从头遍历的限制,链头前驱指向null，链尾指向Null。<br>
用A B C三个人举例就是：A和B互相知道对方是卧底，B和C也互相知道对方是卧底，这样就组成了一个双向链表结构了。
![双向链表](https://blossom102er.github.io/assets/img/double-list.jpg)

* 循环链表：每个指针next都存在后继内存结构，如果是双向链表，则prev指针也会存在前驱内存结构；
![循环链表](https://blossom102er.github.io/assets/img/xunhuan.jpg)


#### 1.2 go实现一个双向链表，简单的例子，熟悉一下双向链表的内存结构
定义一个node，需要有prev，next和value

    type Node struct {
    	Prev,Next  *Node
    	Value string
    }
    
    func NewNode(value string) *Node {
    	return &Node{
    		Value: value,
    	}
    }
    
    func (n *Node) GetPrev() *Node {
    	return n.Prev
    }
    
    func (n *Node) GetNext() *Node {
    	return n.Next
    }
    
    func (n *Node) GetValue() string {
    	return n.Value
    }

定义一个list，可以实现添加node和查找某个index的node
    
    type List struct {
    	Head,Tail   *Node
    	Length int
    }
    
    func NewList() *List {
    	return &List{}
    }
    
    func (l *List) GetHead() *Node {
    	return l.Head
    }
    
    func (l *List) GetTail() *Node {
    	return l.Tail
    }
    
    func (l *List) GetLen() int {
    	return l.Length
    }
    
    func (l *List) RPush(value string) {
    	node := NewNode(value)
    	if l.GetLen() == 0 {
    		l.Head = node
    		l.Tail = node
    	} else {
    		tail := l.Tail
    		tail.Next = node
    		node.Prev = tail
    		l.Tail=node
    	}
    	l.Length = l.Length + 1
    }
    
    func (l *List) SearchNode(index int) (node *Node) {
    
    	if l.Length == 0 {
    		return nil
    	}
    	node=l.Head
    	for ; index > 0 && node != nil; index-- {
    		node = node.GetNext()
    	}
    	return
    }

#### 1.3 go标准库的list实现
go的container/list包内部实现原理就是双向链表，有兴趣可以阅读下标准包的源码。

### 总结
我们都知道线性表分顺序存储结构和链式存储结构，可以比较下这两种结构：<br>
* 顺序存储结构，相邻元素的内存地址是连续的，node1和node2之间并没有空隙，这样导致是插入和删除操作需要移动大量元素；
* 链式存储结构，不关心存储位置，只需要让每个元素知道后继元素存放地址即可。这样删除和插入都只需要更改后继元素的next指针；

