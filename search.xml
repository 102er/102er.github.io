<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git版本回退</title>
    <url>/2021/10/10/git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
    <content><![CDATA[<h3 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h3><p>git在代码回滚提供了多种方式，比如：git reset…，git revert…，git rebase…等，使用哪种方式回退，取决于实际回退场景。</p>
<span id="more"></span>

<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>回退版本，直接把代码回退到某个提交，以实际例子，演示下需要如何回退：</p>
<p><img src="https://102er.github.io/images/git-reset-log.png" alt="avatar"></p>
<p>看提交记录，我们把dev分支不小心合并到了当前特性分支，需要剪掉dev的分支，保证功能分支的特性唯一。从分支线图看出，我们需要回退到 commit id = a94308f 这个版本，问题点是，我们在dev合并之后，又commit了几个记录，我们的目的是剪掉dev合并这次记录，如果是普通的commit 那么我们可以用git revert 撤销这个提交。但是这个是merge操作，没办法。所以，只能回退到a94308f这个版本，然后把dev后的提交pick进来。具体命令如下：</p>
<ol>
<li>git reset –hard  a94308f  #回退到这个版本，并清空其他提交内容</li>
<li>git cherry-pick fb9e36f    #找回消失的提交记录</li>
<li>git cherry-pick 6d60f55   #找回消失的提交记录</li>
<li>如果有冲突，需要解决冲突，然后执行：git cherry-pick –continue</li>
<li>最后再提交到远程 需要强制覆盖远程：git push -f</li>
</ol>
<p>这样就实现了版本的回退。有时候，我们发现要回退版本的时候，已经有很多人提交了。这时候 如果在使用git reset+cherry-pick方式，那不得疯了。基于cherry-pick之上，我们可以使用<strong>git rebase -i</strong> 互动模式，帮助我们解决多量commit的场景。</p>
<p>常用命令：</p>
<ul>
<li>使用 <code>git reset HEAD^</code> 回到上一個 patch（檔案內容不清空）</li>
<li>使用 <code>git reset --hard HEAD^</code> 回到上一個 patch，並且強制清除修改的內容 </li>
<li>使用 <code>git reset --hard &lt;commit id&gt;</code> 直接 reset 成指定的 patch</li>
<li>使用 git reset –soft HEAD^  回到前一個 patch，但保持檔案狀態為 *<strong>Changes to be committed*</strong></li>
<li><strong>– hard  要慎用此参数，它会删除回退点之前的所有修改内容。</strong>如果代码未提交，那就很难补救了，如果代码已经提交，那可以通过找到commit id 找回代码</li>
</ul>
<h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><p>revert一般在剔除部分提交。比如，我不需要commit=057c752,就可以执行：<code>git revert -n 057c752</code>  它可以帮忙我们移除一个commit；它仅仅只是踢掉这个commit，其他的commit还是在的。常用命令：</p>
<ul>
<li>使用 <code>git revert &lt;commit id&gt;</code> 還原指定的 patch</li>
<li>使用 <code>git revert --continue</code> 告知 git 已經解完衝突</li>
<li>使用 <code>git revert --abort</code> 來要放棄這次 revert</li>
<li>不适用于合并操作的commit</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>reset 适用于回退版本到当前版本没有新的commit，而revert是剪掉某个commit记录。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus</title>
    <url>/2021/03/23/prometheus/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>监控</category>
      </categories>
  </entry>
  <entry>
    <title>protoc使用</title>
    <url>/2021/11/12/protoc%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>grpc使用protobuf进行数据的序列化和反序列化，在开发中经常需要写proto文件，进行接口声明定义，然后通过protoc工具转成相应的代码文件，protoc工具不支持生成go代码文件，需要按照相应的插件协助；本文主要介绍protoc工具的使用，以及proto文件的定义。</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="protoc指令"><a href="#protoc指令" class="headerlink" title="protoc指令"></a>protoc指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protoc	--proto_path=api/v1 \</span><br><span class="line">        -I=api/v2 \</span><br><span class="line">			 --gogo_out=paths=source_relative:. \</span><br><span class="line">       api/v1/hello_world.proto</span><br></pre></td></tr></table></figure>

<p> <strong>-IPATH, –proto_path=PATH 也可以用 -I</strong>：它表示protoc在哪个路径下搜索proto文件，可以重复使用这个参数，表示指定多个目录进行搜索。啥场景需要指定这个参数？</p>
<p>— 很多情况下，我们会在一个proto文件里面import其他proto文件，就需要指定这个路径，使protoc可以找到依赖。</p>
<p><strong>–xxx_out=OUT_DIR</strong>：指定使用哪个插件生成相应语言的代码。go需要自己安装插件，一般会选择官方的protoc-gen-go 【–go_out=XXXX】，如果对自定义要求高，可以了解protoc-gen-gogo 【–gogo_out=XXXX】；<code>--xxx_out</code>主要的两个参数为<code>plugins</code> 和 <code>paths</code>，分别表示生成Go代码所使用的插件，以及生成的Go代码的位置。<code>--go_out</code>的写法是，参数之间用逗号隔开，最后加上冒号来指定代码的生成位置，比如<code>--go_out=plugins=grpc,paths=import:.</code></p>
<ul>
<li><code>paths</code>参数有两个选项，分别是 <code>import</code> 和 <code>source_relative</code>，默认为 import，表示按照生成的Go代码的包的全路径去创建目录层级，source_relative 表示按照 <strong>proto源文件的目录层级</strong>去创建Go代码的目录层级，如果目录已存在则不用创建。</li>
<li>​    <code>plugins</code>参数有不带grpc和带grpc两种（应该还有其它的，目前知道的有这两种），两者的区别如下，带grpc的会多一些跟gRPC相关的代码，实现gRPC通信：</li>
</ul>
<p><code>paths</code>参数有两个选项，分别是 <code>import</code> 和 <code>source_relative</code>，默认为 import，表示按照生成的Go代码的包的全路径去创建目录层级，source_relative 表示按照 <strong>proto源文件的目录层级</strong>去创建Go代码的目录层级，如果目录已存在则不用创建。</p>
<p>  **  @<filename> ** ：表示要生成的proto文件，可以是一个目录，它会把目录下所有proto文件生成对应的代码。</p>
<h3 id="proto文件"><a href="#proto文件" class="headerlink" title="proto文件"></a>proto文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package helloWorld;</span><br><span class="line"></span><br><span class="line">option go_package=&quot;api/v1&quot;;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>syntax：指定proto版本，默认是proto2进行编译</li>
<li><code>package</code>：是proto文件的命名空间，避免我们定义的service、message出现冲突。</li>
<li>go_package：生成go语言对应的包路径，对应go的包名，它的设置上需要和–go_out==xxx相同，保证go能够被正确引用。（当然，不一样也可以，这样需要保证go_out目录下只有这个包，不然就会出现冲突，所以，我们设置上一般保证相同，减少不必要的问题）</li>
<li>注意，不同包之间的 proto 文件不可以循环依赖，这会导致生成的 go 包之间也存在循环依赖，导致 go 代码编译不通过。</li>
</ul>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/08/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找（binary search），也称折半搜索（half-interval search）、对数搜索（logarithmic search），是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。</p>
<p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<span id="more"></span>

<p>返回第一次匹配中的目标值，代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nums是有序数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">      mid := (left + right) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">         <span class="keyword">return</span> mid</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">         right = mid - <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         left = mid + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(\log n)<em>O</em>(log<em>n</em>)，其中 n<em>n</em> 是数组的长度。</p>
<p>数组有重复元素的情况下，返回目标值在数组中最小索引位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearchLeftBound</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">      mid := (left + right) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">         right = mid - <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">         left = mid + <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         right = mid - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//没有匹配值</span></span><br><span class="line">   <span class="keyword">if</span> left == <span class="built_in">len</span>(nums) || nums[left] != target &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组有重复元素的情况下，返回目标值在数组中最大索引位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearchRightBound</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">      mid := (left + right) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">         right = mid - <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">         left = mid + <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         left = mid + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> right&lt;<span class="number">0</span> || nums[right] != target &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2021/08/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>二叉树是一种「数据结构」，二叉树是每个节点最多有<code>**两个子树**</code>的树结构，通常子树被称作“左子树”和“右子树”。如下图：</p>
<p><img src="https://102er.github.io/uploads/2chashu.png" alt="osi"></p>
<ul>
<li><strong>满二叉树</strong>：对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满二叉树。</li>
<li><strong>完全二叉树：</strong>对于一棵具有nn个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为ii的节点与同样深度的满二叉树中编号为ii的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。</li>
</ul>
<span id="more"></span>

<p>二叉树的遍历包括前序，中序，后序和层序几种不同的遍历方式。</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>首先遍历根节点，其次遍历左孩子，再遍历右孩子，按照如此的顺序遍历整棵树，遍历结果如下：</p>
<table>
<thead>
<tr>
<th>6</th>
<th>9</th>
<th>23</th>
<th>5</th>
<th>10</th>
<th>7</th>
<th>8</th>
<th>22</th>
<th>34</th>
</tr>
</thead>
</table>
<p>代码实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">   Val   <span class="keyword">int</span></span><br><span class="line">   Left  *TreeNode</span><br><span class="line">   Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> preorder <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">   <span class="keyword">var</span> result []<span class="keyword">int</span></span><br><span class="line">   preorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">      preorder(node.Left) <span class="comment">//遍历左树</span></span><br><span class="line">      preorder(node.Right) <span class="comment">//遍历右树</span></span><br><span class="line">   &#125;</span><br><span class="line">   preorder(root)</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>首先遍历左子树，其次遍历父节点，最后遍历右子树，按照如此的顺序遍历整棵树</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>首先遍历左子树，其次遍历右子树，最后遍历父节点</p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>需要使用链表存储每一层的节点，同时，遍历完一个节点，将其左右子节点增加近链表中</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>mysql索引介绍</title>
    <url>/2020/03/12/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。<br>　　MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。<br>　　创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)，而不是在select的字段中，实际上，索引也是一张“表”，该表保存了主键与索引字段，并指向实体表的记录，虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件。说白了索引就是用来提高速度的，但是就需要维护索引造成资源的浪费，所以合理的创建索引是必要的。</p>
<span id="more"></span>

<h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2>]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据类型</title>
    <url>/2020/08/19/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>go实现keycloak adaptor</title>
    <url>/2021/12/09/go%E5%AE%9E%E7%8E%B0keycloak%20adaptor/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>IAM：</strong>Identity and Access Management的缩写，即身份识别与访问管理，具有单点登录(SSO-Single Sign On)，认证管理，基于策略的集中式授权和审计，动态授权等功能。</p>
<p><strong>keycloak：</strong>是IAM的解决方案，用于管理用户的注册、登录、单点登录Single Sign On（SSO）、开放app接口的授权等。</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>keycloak并没有提供go的接入适配器，所以需要我们自行实现。接入keycloak有两种常用的认证方式：</p>
<ol>
<li>OpenID Connect（oidc）：在oauth2.0上的一种授权认证协议，OIDC使用OAuth2的授权服务器来为第三方客户端提供用户的身份认证，并把对应的身份认证信息传递给客户端，且可以适用于各种类型的客户端（比如服务端应用，移动APP，JS应用），且完全兼容OAuth2，也就是说你搭建了一个OIDC的服务后，也可以当作一个OAuth2的服务来用。</li>
<li>SAML：认证授权协议</li>
</ol>
<p>两种方式都可接入，oidc会相对简单一点。（当然，还得看我们iam是否有配置两种协议的endpoint）</p>
<p>我们选择用oidc的认证方式接入IAM。OIDC是OpenID Connect的简称，OIDC=(Identity, Authentication) + OAuth 2.0。它在OAuth2上构建了一个身份层，是一个基于OAuth2协议的身份认证标准协议。具体可以参考文档：<a href="https://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto-id-0">https://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto-id-0</a></p>
<p>go生态有go-oidc和oauth2.0组件，可以帮助我们解决和iam交互工作，我们只需负责提供认证流程需要的接口即可。认证交互流程图：</p>
<p><img src="https://102er.github.io/uploads/iam-login.png" alt="osi"></p>
<h3 id="oidc和oauth初始化"><a href="#oidc和oauth初始化" class="headerlink" title="oidc和oauth初始化"></a><strong>oidc和oauth初始化</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IAM <span class="keyword">struct</span> &#123;</span><br><span class="line">	oauth2Cfg      *oauth2.Config</span><br><span class="line">	oidcVerifier   *oidc.IDTokenVerifier</span><br><span class="line">	state          <span class="keyword">string</span> <span class="comment">//随机状态 目前是固定的</span></span><br><span class="line">	feRedirectURL  <span class="keyword">string</span> <span class="comment">//前端回调地址</span></span><br><span class="line">	serverLoginUrl <span class="keyword">string</span> <span class="comment">//服务端登录接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Iam <span class="keyword">struct</span> &#123;</span><br><span class="line">	ClientID            <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=ClientID,proto3&quot; json:&quot;ClientID,omitempty&quot;`</span>                       <span class="comment">// 客户端名称从keycloak 中获取，resource</span></span><br><span class="line">	ClientSecret        <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,2,opt,name=ClientSecret,proto3&quot; json:&quot;ClientSecret,omitempty&quot;`</span>               <span class="comment">// 客户端密钥从keycloak 中获取，credentials.secret</span></span><br><span class="line">	LogoutCallbackAddr  <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,3,opt,name=LogoutCallbackAddr,proto3&quot; json:&quot;LogoutCallbackAddr,omitempty&quot;`</span>   <span class="comment">// IAM登出之后的回调地址</span></span><br><span class="line">	LoginCallbackAddr   <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,4,opt,name=LoginCallbackAddr,proto3&quot; json:&quot;LoginCallbackAddr,omitempty&quot;`</span>     <span class="comment">// IAM登录成功之后 应该回调的前端地址</span></span><br><span class="line">	FeLoginCallbackAddr <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,5,opt,name=FeLoginCallbackAddr,proto3&quot; json:&quot;FeLoginCallbackAddr,omitempty&quot;`</span> <span class="comment">// 登录成功之后，前端回调地址</span></span><br><span class="line">	AuthServer          <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,6,opt,name=AuthServer,proto3&quot; json:&quot;AuthServer,omitempty&quot;`</span> <span class="comment">// IAM授权地址</span></span><br><span class="line">	ServerLoginUrl      <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,9,opt,name=ServerLoginUrl,proto3&quot; json:&quot;ServerLoginUrl,omitempty&quot;`</span> <span class="comment">// 后端登录接口地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIAMClient</span><span class="params">(params *conf.Iam)</span> <span class="params">(*iamClient, error)</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	provider, err := oidc.NewProvider(ctx, params.AuthServer) <span class="comment">//获取endpoint信息，但是我们的iam架构之间加了一层， 所以并没有使用这个返回结果</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	oauth2Config := &amp;oauth2.Config&#123;</span><br><span class="line">		ClientID:     params.ClientID,</span><br><span class="line">		ClientSecret: params.ClientSecret,</span><br><span class="line">		RedirectURL:  params.LoginCallbackAddr,</span><br><span class="line">		<span class="comment">// Discovery returns the OAuth2 endpoints.</span></span><br><span class="line">		Endpoint: provider.Endpoint(),</span><br><span class="line">		<span class="comment">// &quot;openid&quot; is a required scope for OpenID Connect flows.</span></span><br><span class="line">		Scopes: []<span class="keyword">string</span>&#123;oidc.ScopeOpenID, <span class="string">&quot;profile&quot;</span>, <span class="string">&quot;email&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	oidcConfig := &amp;oidc.Config&#123;</span><br><span class="line">		ClientID:          params.ClientID,</span><br><span class="line">		SkipClientIDCheck: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	verifier := provider.Verifier(oidcConfig)</span><br><span class="line">	<span class="keyword">return</span> &amp;iamClient&#123;</span><br><span class="line">		oauth2Cfg:      oauth2Config,</span><br><span class="line">		oidcVerifier:   verifier,</span><br><span class="line">		state:          strconv.FormatInt(time.Now().Unix(), <span class="number">10</span>), <span class="comment">//理论上需要随机生成，随机生成 需要用额外的存储 才能校验</span></span><br><span class="line">		feRedirectURL:  params.FeLoginCallbackAddr,</span><br><span class="line">		serverLoginUrl: params.ServerLoginUrl,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由接口实现"><a href="#路由接口实现" class="headerlink" title="路由接口实现"></a>路由接口实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Iam *IAM</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LoginUrlHandler 获取iam登录地址接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserRepo)</span> <span class="title">LoginUrlHandler</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> u.Iam.oauth2Cfg.AuthCodeURL(u.Iam.state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoginCallback 授权码验证接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserRepo)</span> <span class="title">LoginCallback</span><span class="params">(ctx context.Context, state, code <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"> 	<span class="comment">//验证iam返回的state</span></span><br><span class="line">	<span class="keyword">if</span> state != u.Iam.state &#123;</span><br><span class="line">		<span class="comment">//认证失败 自定义返回错误</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//iam返回的授权码code 去交换token</span></span><br><span class="line">	oauth2Token, err := u.Iam.oauth2Cfg.Exchange(ctx, code)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//认证失败 自定义返回错误</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出access_token 因为iam从oidc退化了 所以 取access_token 正常是取 id_token</span></span><br><span class="line">  <span class="comment">//rawIDToken, ok := oauth2Token.Extra(&quot;id_token&quot;).(string)</span></span><br><span class="line">	accessToken, ok := oauth2Token.Extra(<span class="string">&quot;access_token&quot;</span>).(<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">//认证失败 自定义返回错误</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从access token中解析 用户信息</span></span><br><span class="line">	idToken, err := u.Iam.oidcVerifier.Verify(ctx, accessToken)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//认证失败 自定义返回错误</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//iam认证成功 可以开始创建本地token</span></span><br><span class="line">  <span class="comment">// ... 自己撸代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redirect iam登录成功回调接口</span></span><br><span class="line"><span class="comment">// ctx根据自己的业务自己改造</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserRepo)</span> <span class="title">RedirectHandler</span><span class="params">(ctx *http.Request)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	query := ctx.URL.RawQuery</span><br><span class="line">	<span class="keyword">return</span> u.Iam.feRedirectURL + <span class="string">&quot;?&quot;</span> + query + <span class="string">&quot;#/cost/dashboard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>认证</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <url>/2021/06/09/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，位于网络分层模型的传输层：</p>
<p><img src="https://102er.github.io/images/osi-model.png" alt="osi"></p>
<ul>
<li>面向连接：两个端必须建立tcp连接，才能通讯交换数据。</li>
<li>基于字节流：tcp连接双方的数据交换是以字节构成的有序但无结构的字节流。</li>
<li>可靠性：通过连接管理，流量控制，拥塞控制，超时重传机制，序号和确认序号等机制保证传输可靠。</li>
</ul>
<span id="more"></span>

<h2 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h2><p><img src="https://102er.github.io/images/tcp-bw.png" alt="osi"></p>
<ul>
<li>端口号：每个tcp报文包含源和目的端口号，2字节的端口号，端口号+ip可以组成一个socket</li>
<li>序号（seq）：数据序号，表示这个数据流在整个数据流中的序号，接收端可以根据序号组装数据</li>
<li>确认序号（ack）：确认序号，接收方成功接收数据，会回复发送端，并把接收的序号+1，告诉发送端自己接收了哪个序号的数据，下次数据要从ack序号开始发</li>
<li>首部长度：记录tcp头的长度，tcp</li>
<li>保留位：暂时没用</li>
<li>标志位：标记请求的目的，状态等<ul>
<li>URG：值为 1 时，紧急指针生效，表示本次报文需要尽快传输，不要按照原本的队列次序传输</li>
<li>ACK：值为 1 时，确认序号生效，表示数据已经被接收</li>
<li>PSH：接收方应尽快将这个报文段交给应用层</li>
<li>RST：发送端遇到问题，想要释放当前连接，重建传输连接。</li>
<li>SYN：同步序号，用于发起一个连接</li>
<li>FIN：发送端要求关闭连接</li>
</ul>
</li>
<li>窗口：TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。</li>
<li>检验和 (Checksum)：强制性必须携带的字段。检验和覆盖了整个 TCP 报文段，包括 TCP 首部和 TCP 数据，发送端根据特定算法对整个报文段计算出一个检验和，接收端会进行计算并验证。</li>
<li>紧急指针 (Urgent Pointer)：当 URG 控制位值为 1 时，此字段生效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</li>
<li>选项 (Options)：这一部分是可选字段，也就是非必须字段，最常见的可选字段是“最长报文大小 (MSS，Maximum Segment Size)”。</li>
<li>有效数据部分 (Data)：这部分也不是必须的，比如在建立和关闭 TCP 连接的阶段，双方交换的报文段就只包含 TCP 首部。</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://102er.github.io/images/tcp-3ws.png" alt="osi"></p>
<ol>
<li>第一次握手：客户端向服务端发送连接请求报文。此时标志位：SYN=1，同时会初始化一个序列号x 填充到 seq序号位。发送完，客户端进入syn-send状态，等待服务端的确认。<u>TCP规定SYN=1的报文不能携带数据，但需要消耗一个序号。</u></li>
<li>第二次握手：服务端接收报文之后，如果同意连接，会发出确认报文，包含标志位：SYN=1,ACK=1，确认序号ack=x+1(<u>x是客户端发送的seq序号值，序号+1代表服务端期望下次接收到客户的数据序号为x+1</u>)，序号seq=y。发送完报文，服务端进入syn-received状态。<u>TCP规定SYN=1的报文不能携带数据，但需要消耗一个序号。</u></li>
<li>第三次握手：客户端接收到确认报文，还需要向服务端给出确认报文，包含标志位：ACK=1，确认序号ack=y+1，序号seq=x+1，此时，tcp连接建立，客户端进入established。<u>TCP规定，ACK报文段可以携带数据，但如果不携带数据，则不消化序号。</u>当服务端接收到客户端的确认报文后也进入established。此后，双方就可以开始通信了。</li>
</ol>
<h3 id="为什么三次握手？"><a href="#为什么三次握手？" class="headerlink" title="为什么三次握手？"></a>为什么三次握手？</h3><ul>
<li>防止已过期的连接请求报文突然又传到服务器，浪费服务器资源<ul>
<li>第三次握手可以对失效请求报文，进行确认，当他接收了失效请求报文会回复，如果客户端是关闭状态的，那没办法进行确认请求，所以服务端收不到客户端确认报文，会判断客户端并没有提交请求连接。（<strong>失效请求</strong>：客户端发送了第一次握手，但是网络因素滞留。客户端迟迟没有接收到服务端的确认报文，会再次发送握手请求。那么此时，第一次发送的握手请求就是失效的。）</li>
</ul>
</li>
<li>三次握手才能确认让双方确认彼此的发送和接收能力<ul>
<li>第一次握手，服务端可以确认自己的<u>接收</u>能力和客户端的<u>发送</u>能力 </li>
<li>第二次握手，客户端可以确认自己的<u>收发</u>能力和服务端的<u>收发</u>能力 </li>
<li>第三次握手，前两次握手，服务端并不能知道自己的<u>发送</u>能力和客户端的<u>接收</u>能力是否正常。第三次握手，服务端收到了客户端第二次握手的回应，从服务端角度可以确认自己第二次握手发送的包发送出去且客户端接收了，所以确认了自己的<u>收发</u>能力和客户端的<u>收发</u>能力。</li>
</ul>
</li>
<li>告知对方自己的初始序号值，并确认收到对方的初始序号值<ul>
<li>三次握手，才能保证服务端发送的seq初始序号得到确认。</li>
</ul>
</li>
</ul>
<h3 id="SYN-FLOOD攻击"><a href="#SYN-FLOOD攻击" class="headerlink" title="SYN FLOOD攻击"></a>SYN FLOOD攻击</h3><p>伪造大量的源ip地址，分别向服务端发送大量的syn包，服务端返回的SYN/ACK包，因为源地址是伪造的，所以不会有应答，服务端没有收到应答，会重试并且等待一个syn time，如果超时则丢弃这个连接。这种半开连接会消耗服务端的资源，导致服务端无法正常服务。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p><img src="https://102er.github.io/images/tcp-4hs.png" alt="osi"></p>
<ol>
<li>客户端发送连接释放报文段并且停止发送数据，此时标志位：FIN 标志位1，序号字段 seq = x (等于之前发送的所有数据的最后一个字节的序号加一)，然后客户端会进入 FIN-WAIT-1 状态，等待来自服务器的确认报文。<u>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</u></li>
<li>服务器收到 FIN 报文后，发回确认报文，此时标志位：ACK = 1， 确认序号段 ack = x + 1，并带上自己的序号 seq = y，此时，服务器就进入 CLOSE-WAIT 状态。服务器还会通知上层的应用程序对方已经释放连接，此时 TCP 处于半关闭状态，即使客户端没有数据要发送，但是服务器还可以发送数据，客户端也还能够接收。</li>
<li>客户端收到服务器的 ACK 报文段后随即进入 FIN-WAIT-2 状态，此时还能收到来自服务器的数据，直到收到 FIN 报文段。</li>
<li>服务器发送完所有数据后，就向客户端发送连接释放报文，此时标志位：ACK=1,FIN=1,序号为seq=z，确认序号ack=x+1，随后服务器进入 LAST-ACK 状态，等待来自客户端的确认报文段。</li>
<li>客户端收到来自服务器的 FIN 报文段后，向服务器发送 ACK 报文，随后进入 TIME-WAIT 状态，等待 2MSL(2 * Maximum Segment Lifetime，两倍的报文段最大存活时间) ，这是任何报文段在被丢弃前能在网络中存在的最长时间，常用值有30秒、1分钟和2分钟。如无特殊情况，客户端会进入 CLOSED 状态。</li>
<li>服务器在接收到客户端的 ACK 报文后会随即进入 CLOSED 状态，由于没有等待时间，一般而言，服务器比客户端更早进入 CLOSED 状态。</li>
</ol>
<h3 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a><strong>为什么客户端最后还要等待2MSL？</strong></h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。这恰恰 就是**2MSL( Maximum Segment Life)。</p>
<ol>
<li>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li>
<li>等待2MSL时间，客户端就可以放心地释放TCP占用的资源、端口号。如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部死翘翘，2MSL时间可以满足这个需求（尽管非常保守）</li>
</ol>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></h3><p>TCP还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必已经将全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>go之xx问</title>
    <url>/2021/08/09/go%E4%B9%8Bxx%E9%97%AE/</url>
    <content><![CDATA[<h4 id="T和-T的调用关系"><a href="#T和-T的调用关系" class="headerlink" title="T和*T的调用关系"></a><code>T</code>和<code>*T</code>的调用关系</h4><p>在Go语言中，为了方便，对于一个非指针和非接口定义类型<code>T</code>，</p>
<ul>
<li>一个<code>T</code>类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此<code>T</code>的值是可寻址的情况下。 编译器在调用指针属主方法前，会自动取此<code>T</code>值的地址。 因为不是任何<code>T</code>值都是可寻址的，所以并非任何<code>T</code>值都能够调用为类型<code>*T</code>声明的方法。 这种便利只是一个语法糖，而不是一种固有的规则。（常量不可寻址）</li>
<li>一个<code>*T</code>类型的值可以调用为类型<code>T</code>声明的方法。 这是因为解引用指针总是合法的。 这种便利不仅仅是一个语法糖，它也是一种固有的规则。</li>
</ul>
<p>所以很合理的， <code>*T</code>的方法集总是<code>T</code>方法集的超集，但反之不然。</p>
<p>事实上，你可以认为对于每一个为类型<code>T</code>声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。</p>
<span id="more"></span>

<h4 id="for和range区别"><a href="#for和range区别" class="headerlink" title="for和range区别"></a>for和range区别</h4><p>range 在迭代过程中返回的是迭代值的拷贝，如果每次迭代的元素的内存占用很低，那么 for 和 range 的性能几乎是一样。但是如果迭代的元素内存占用较高，例如一个包含很多属性的 struct 结构体，那么 for 的性能将显著地高于 range，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 for，如果使用 range，建议只迭代下标，通过下标访问迭代值，这种使用方式和 for 就没有区别了。如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针，才能不影响性能。</p>
<h4 id="数组和切片区别"><a href="#数组和切片区别" class="headerlink" title="数组和切片区别"></a>数组和切片区别</h4><p>数组是不可变的数据类型，线程安全</p>
<p>切片是动态可变的数据结构，包含长度，容量以及指向数组的应用，线程不安全</p>
<h4 id="rune数据类型"><a href="#rune数据类型" class="headerlink" title="rune数据类型"></a>rune数据类型</h4><p>rune是Go语言中一种特殊的数据类型,它是int32的别名,几乎在所有方面等同于int32,用于区分字符值和整数值。</p>
<p>补充：golang中的字符有两种，uint8（byte）代表ASCII的一个字符，rune代表一个utf-8字符。</p>
<p>理解：当需要处理中文、日文或者其他复合字符时，则需要用到rune类型，rune实际是一个int32.</p>
<h4 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h4><ul>
<li>不同包的 <code>init()</code>执行顺序，按照 <code>导入包的依赖关系</code> 决定</li>
<li><code>init()</code> 不能被其他函数调用，而自动 <code>在main函数执行前</code> 被调用</li>
<li>执行顺序：import –&gt; const –&gt; var –&gt; init() –&gt; main()</li>
</ul>
<h4 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h4><ul>
<li>new可以初始化所有类型，为类型申请一块内存空间并返回一个指针</li>
<li>make只能用于map ，channel，slice初始化，返回的是类型引用</li>
</ul>
<h4 id="什么是协程泄露-Goroutine-Leak-？"><a href="#什么是协程泄露-Goroutine-Leak-？" class="headerlink" title="什么是协程泄露(Goroutine Leak)？"></a>什么是协程泄露(Goroutine Leak)？</h4><p>go协程正常结束后，会被gc回收，但是如果一些操作不当，就会引起协程一直处于阻塞状态或者永远运行，这种情况就是协程泄漏了，他会一直消耗资源，直到系统奔溃。泄漏的场景：</p>
<ul>
<li>Goroutine 内正在进行 channel/mutex 等读写操作，但由于逻辑问题，某些情况下会被一直阻塞。</li>
<li>Goroutine 内的业务逻辑进入死循环，资源一直无法释放。</li>
<li>Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待。</li>
</ul>
<p>检测工具：uber-go/goleak</p>
<h4 id="赋值是原子操作吗？"><a href="#赋值是原子操作吗？" class="headerlink" title="赋值是原子操作吗？"></a>赋值是原子操作吗？</h4><p>不是原子操作，会有并发安全问题。设计struct赋值的数据类型 都是并发不安全的 比如slice map等</p>
<h4 id="time-Sleep-d-和-lt-time-After-d-有何区别？"><a href="#time-Sleep-d-和-lt-time-After-d-有何区别？" class="headerlink" title="time.Sleep(d)和&lt;-time.After(d)有何区别？"></a><code>time.Sleep(d)</code>和<code>&lt;-time.After(d)</code>有何区别？</h4><p>两者都会将当前的goroutine执行暂停一段时间。 区别在于<code>time.Sleep(d)</code>函数调用将使当前的协程进入睡眠子状态，但是当前协程的<a href="https://gfw.go101.org/article/control-flows-more.html#states-of-goroutine">（主）状态</a>依然为运行状态； 而通道接收<code>&lt;-time.After(d)</code>操作将使当前协程进入阻塞状态。</p>
<h4 id="哪些类型不支持比较？"><a href="#哪些类型不支持比较？" class="headerlink" title="哪些类型不支持比较？"></a>哪些类型不支持比较？</h4><p>下列类型不支持比较：映射（map、切片、函数、包含不可比较字段的结构体类型、元素类型为不可比较类型的数组类型</p>
<p>不支持比较的类型不能用做映射类型的键值类型。请注意：</p>
<ul>
<li>尽管映射，切片和函数值不支持比较，但是它们的值可以与类型不确定的<code>nil</code>标识符比较。</li>
<li>如果两个接口值的动态类型相同且不可比较，那么在运行时<a href="https://gfw.go101.org/article/interface.html#comparison">比较这两个接口的值</a>会产生一个恐慌。</li>
</ul>
<h4 id="为什么两个nil值有时候会不相等？"><a href="#为什么两个nil值有时候会不相等？" class="headerlink" title="为什么两个nil值有时候会不相等？"></a>为什么两个<code>nil</code>值有时候会不相等？</h4><p>一个接口值可以看作是一个包裹非接口值的盒子。被包裹在一个接口值中的非接口值的类型必须实现了此接口值的类型。 在Go中，很多种类型的类型的零值都是用<code>nil</code>来表示的。 一个什么都没包裹的接口值为一个零值接口值，即nil接口值。 一个包裹着其它非接口类型的nil值的接口值并非什么都没包裹，所以它不是（或者说它不等于）一个nil接口值。</p>
<p>当对一个nil接口值和一个nil非接口值进行比较时（假设它们可以比较），此nil非接口值将先被转换为nil接口值的类型，然后再进行比较； 此转换的结果为一个包裹了此nil非接口值的一个副本的接口值，此接口值不是（或者说它不等于）一个nil接口值，所以此比较不相等。</p>
<h4 id="哪些值可以被取地址，哪些值不可以被取地址？"><a href="#哪些值可以被取地址，哪些值不可以被取地址？" class="headerlink" title="哪些值可以被取地址，哪些值不可以被取地址？"></a>哪些值可以被取地址，哪些值不可以被取地址？</h4><p>以下的值是不可以寻址的：</p>
<ul>
<li>字符串的字节元素</li>
<li>映射元素</li>
<li>接口值的动态值（类型断言的结果）</li>
<li>常量（包括有名常量和字面量）</li>
<li>声明的包级别函数</li>
<li>方法（用做函数值）</li>
<li>中间结果值<ul>
<li>函数调用</li>
<li>显式值转换</li>
<li>各种操作，不包含指针解引用（dereference）操作，但是包含：<ul>
<li>通道接收操作</li>
<li>子字符串操作</li>
<li>子切片操作</li>
<li>加法、减法、乘法、以及除法等等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以下的值是可寻址的，因此可以被取地址：变量</p>
<p>可寻址的结构体的字段</p>
<ul>
<li>可寻址的数组的元素</li>
<li>任意切片的元素（无论是可寻址切片或不可寻址切片）</li>
<li>指针解引用（dereference）操作</li>
</ul>
<h4 id="为什么映射元素不可被取地址？"><a href="#为什么映射元素不可被取地址？" class="headerlink" title="为什么映射元素不可被取地址？"></a>为什么映射元素不可被取地址？</h4><p>在Go中，映射的设计保证一个映射值在内存允许的情况下可以加入任意个条目。 另外为了防止一个映射中为其条目开辟的内存段支离破碎，官方标准编译器使用了哈希表来实现映射。 并且为了保证元素索引的效率，一个映射值的底层哈希表只为其中的所有条目维护一段连续的内存段。 因此，一个映射值随着其中的条目数量逐渐增加时，其维护的连续的内存段需要不断重新开辟来增容，并把原来内存段上的条目全部复制到新开辟的内存段上。 另外，即使一个映射值维护的内存段没有增容，某些哈希表实现也可能在当前内存段中移动其中的条目。 总之，映射中的元素的地址会因为各种原因而改变。 如果映射元素可以被取地址，则Go运行时（runtime）必须在元素地址改变的时候修改所有存储了元素地址的指针值。 这极大得增加了Go编译器和运行时的实现难度，并且严重影响了程序运行效率。 因此，目前，Go中禁止取映射元素的地址。</p>
<p>映射元素不可被取地址的另一个原因是表达式<code>aMap[key]</code>可能返回一个存储于<code>aMap</code>中的元素，也可能返回一个不存储于其中的元素零值。 这意味着表达式<code>aMap[key]</code>在<code>(&amp;aMap[key]).Modify()</code>调用执行之后可能仍然被估值为元素零值。 这将使很多人感到困惑，因此在Go中禁止取映射元素的地址。</p>
<h4 id="函数返回局部变量的指针是否安全？"><a href="#函数返回局部变量的指针是否安全？" class="headerlink" title="函数返回局部变量的指针是否安全？"></a>函数返回局部变量的指针是否安全？</h4><p>是的，在Go中这是绝对安全的。</p>
<p>支持栈的Go编译器将会对每个局部变量进行逃逸分析。 对于官方标准编译器来说，如果一个值可以在编译时刻被断定它在运行时刻仅会在一个协程中被使用，则此值将被开辟在（此协程的）栈上；否则此值将被开辟在堆上。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>go调度模型-GMP</title>
    <url>/2020/11/19/go%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B-GMP/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>调度的进化 ：从进程到线程再到协程，其实就是不断共享，不断减少切换成本。go协程，在语言层面封装了协程调度，使用起来更方便。</p>
<span id="more"></span>

<h4 id="并发-amp-并行"><a href="#并发-amp-并行" class="headerlink" title="并发&amp;并行"></a><strong>并发</strong>&amp;并行</h4><p><strong>并发：</strong>某一段时间，几个程序在同一个cpu上运行，但任意一个时间点只有一个程序在运行。解决程序排队等待的问题，如果一个程序发生阻塞，那么其他程序仍可以正常的执行。站在cpu的角度上，并发实际也是串行的。</p>
<p><strong>并行</strong>：需要硬件支持，系统必须具备多个cpu，才能有并行的能力。不同cpu在同一时间运行不同程序，互不抢占资源，实现真正的同时执行。</p>
<p><strong>区别</strong>：并发只是在宏观上给人感觉多个程序在同时运行，但实际单cpu系统中，每一时刻只有一个程序在运行。而并行关键是多核【同时】执行。</p>
<h4 id="进程-amp-线程-amp-协程"><a href="#进程-amp-线程-amp-协程" class="headerlink" title="进程 &amp; 线程 &amp; 协程"></a><strong>进程</strong> &amp; 线程 &amp; 协程</h4><p><strong>进程：</strong>用于划分程序运行时所需要的资源(IO资源，信号处理，内存资源等)，是程序运行的基本资源单位(最小单位)；不共享堆栈，由操作系统调度，属于抢占式调度，有三个状态：等待，就绪和运行状态。进程之间是互相隔离，各自拥有独立的系统资源，更加安全但是进程间通信不方便。</p>
<p>进程间通讯方式：管道，信号，消息队列，共享内存，socket</p>
<p><strong>线程</strong>：系统进行运算调度的最小单位，一个进程至少包含一个线程(主线程)；线程由线程ID，当前指令指针，寄存器集合和堆栈组成，不拥有系统资源，进程内的所有线程共享进程资源；共享堆，不共享栈，由操作系统调度，属于抢占式调度。</p>
<p>线程间通讯方式：互斥量，信号量</p>
<p><strong>协程</strong>：用户级线程，是执行流，并不是运行实体，内核并不知道协程存在，共享堆，不共享栈，拥有自己的寄存器上下文和栈，由用户程序进程调度，是协作式调度，需要协程自己主动把控制权转让出去。</p>
<p><strong>区别</strong>：进程是cpu资源分配的基本单位，线程是独立运行和独立调度的基本单位；进程拥有自己的资源空间，一个进程包含了N个线程，线程和cpu资源分配无关，多个线程共享同一进程内的资源；线程的调度与切换比进程快很多(进程切换涉及资源切换，但是线程切换不需要)；协程和线程的区别，协程调度发生在用户态，无需线程上下文切换开销，而线程调度发生在内核态，所以协程调度会更加轻量。</p>
<h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><p><strong>M</strong>：代表OS线程，一个M就是一个线程，真正的执行者，数量比P多，M创建之后，会去P的free list寻找可用P进行绑定，如果没有绑定到P，则进入阻塞状态</p>
<p><strong>G</strong>：go func出来的goroutine，代表一个用户代码的只执行流，拥有独立的栈空间</p>
<p><strong>P</strong>：默认机器的核数，表示执行所需要的资源，P的数量代表最大并行程度，一个P对应多个M，但是同一时刻，只有一个M与P绑定；每个P都有一个本地存放G的队列，M和P绑定时，如果新生成的G会放入本地runq中，本地队列满了，会截取本地队列一半的G放入全局队列中。p减少了锁竞争以及增加了资源利用率。</p>
<p><strong>调度流程如下：</strong></p>
<ol>
<li>go func创建一个G对象，会保存在全局runq或者本地的runq（先放在生成G的线程runq下，如果队列满了，会放到全局runq）</li>
<li>G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；</li>
<li>当go func的时候，G去唤醒一个M，M寻找是否有空闲的P，如果有则将该G对象移动到它本身</li>
<li>M执行一个调度循环：<ol>
<li>调度G对象，G对象来源：1/61的几率从全局队来，60/61的几率在本地队列寻找G</li>
<li>执行 -&gt; 清理线程 -&gt; 继续寻找新的G</li>
</ol>
</li>
<li>p的某个G发生网络调用(或者系统调用，因为和系统交互是线程，所以当前M是阻塞的)，那么P和M会解绑，P会带着其他G去寻找新的M(找空闲的M，如果没有则new一个出来)</li>
<li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</li>
</ol>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>go并发通信-channel</title>
    <url>/2021/05/22/go%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1-channel/</url>
    <content><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>管道，保证线程安全，用于数据传递或者数据共享，属于先进先出的队列。实现 Channel 的结构并不神秘，本质上就是一个 <code>mutex</code> 锁加上一个环状缓存、 一个发送方队列和一个接收方队列。</p>
<span id="more"></span>

<h3 id="通信交互"><a href="#通信交互" class="headerlink" title="通信交互"></a>通信交互</h3><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a><strong>发送消息</strong></h4><ol>
<li>持有锁</li>
<li>入队，拷贝要发送的数据<ol>
<li>找到是否有正在阻塞的接收方，是则直接发送</li>
<li>找到是否有空余的缓存，是则存入</li>
<li>阻塞直到被唤醒</li>
</ol>
</li>
<li>释放锁</li>
</ol>
<h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a><strong>接收消息</strong></h4><ol>
<li>上锁</li>
<li>从缓存中出队，拷贝要接收的数据<ol>
<li>如果 Channel 已被关闭，且 Channel 没有数据，立刻返回</li>
<li>如果存在正在阻塞的发送方，说明缓存已满，从缓存队头取一个数据，再复始一个阻塞的发送方</li>
<li>否则，检查缓存，如果缓存中仍有数据，则从缓存中读取，读取过程会将队列中的数据拷贝一份到接收方的执行栈中</li>
<li>没有能接受的数据，阻塞当前的接收方 Goroutine</li>
</ol>
</li>
<li>解锁</li>
</ol>
<h3 id="通道关闭"><a href="#通道关闭" class="headerlink" title="通道关闭"></a>通道关闭</h3><h4 id="channel关闭后的读写"><a href="#channel关闭后的读写" class="headerlink" title="channel关闭后的读写"></a><strong>channel关闭后的读写</strong></h4><ul>
<li>关闭后的channel，可以读数据，因为channel中，可能会有缓存数据存在</li>
<li>关闭后的channel，如果再写数据，会引起panic异常，可以判断是否channel关闭，防止panic产生</li>
<li>nil的channel读写都会阻塞，再次close会引起panic</li>
</ul>
<h4 id="关闭原则"><a href="#关闭原则" class="headerlink" title="关闭原则"></a>关闭原则</h4><p>一个常用的使用Go通道的原则是<strong>不要在数据接收方或者在有多个发送者的情况下关闭通道</strong>。 换句话说，我们只应该让一个通道唯一的发送者关闭此通道。</p>
<ul>
<li>情形一：M个接收者和一个发送者。发送者通过关闭用来传输数据的通道来传递发送结束信号</li>
<li>情形二：一个接收者和N个发送者，此唯一接收者通过关闭一个额外的信号通道来通知发送者不要在发送数据了</li>
<li>情形三：M个接收者和N个发送者。它们中的任何协程都可以让一个中间调解协程帮忙发出停止数据传送的信号</li>
<li>情形四：“M个接收者和一个发送者”情形的一个变种：用来传输数据的通道的关闭请求由第三方发出</li>
</ul>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>go初始化函数-init</title>
    <url>/2020/04/10/go%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0-init/</url>
    <content><![CDATA[<h2 id="init-函数是什么？"><a href="#init-函数是什么？" class="headerlink" title="init()函数是什么？"></a>init()函数是什么？</h2><p> <code>init()</code> 函数是隐式调用的，即会在包引入就执行，在编译的时候，已经确保 <code>init</code> 会在 <code>main</code>执行之前就被调用。</p>
<span id="more"></span>

<h2 id="函数特点"><a href="#函数特点" class="headerlink" title="函数特点"></a>函数特点</h2><ul>
<li>程序运行前，进行包的初始化工作</li>
<li>每个包，每个go文件可以拥有多个init函数，<u>顺序不能保证从上到下执行</u></li>
<li>没有参数，不能被其他函数调用，是在<u>main函数执行前自动被调用</u></li>
<li>只会执行一次，即使这个包被多个包import</li>
</ul>
<h2 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h2><p>go程序初始化执行顺序：import –&gt; const –&gt; var –&gt; init()</p>
<p><img src="https://102er.github.io/uploads/init.png" alt="osi"></p>
<ol>
<li>如果一个包导入了其他包，则首先初始化导入的包。</li>
<li>然后初始化当前包的常量。</li>
<li>接下来初始化当前包的变量。</li>
<li>最后，调用当前包的 <code>init()</code> 函数。</li>
</ol>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>服务部署nginx+keepalived</title>
    <url>/2020/05/19/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2nginx+keepalived/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>服务部署</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>go获取ip地理信息</title>
    <url>/2021/06/14/go%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MMDB即Maxmind DB，是一个设计用于存储IPv4和IPv6的数据信息的数据库，mmdb文件是一个二进制格式的文件，它使用一个<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>树加速IP信息的查询。ps：网上有一些免费但是更新不及时的ip库，如果用于公司商业化，建议购买ip库。</p>
<h2 id="GO解析mmdb文件"><a href="#GO解析mmdb文件" class="headerlink" title="GO解析mmdb文件"></a>GO解析mmdb文件</h2><p>GO基于IP获取地理信息有两个库：</p>
<ul>
<li>github.com/oschwald/maxminddb-golang 可以解析标准的mmdb文件</li>
<li>github.com/oschwald/geoip2-golang 提供了更多的api操作， 底层也是调用了maxminddb-golang包来做数据的解析，仅仅做了一层接口上的封装，和对应地理数据格式（企业、城市、国家、AnonymousIP、Domain、ISP）的定义。 但是只适用于<a href="http://dev.maxmind.com/geoip/geoip2/geolite2/">GeoLite2</a> and <a href="http://www.maxmind.com/en/geolocation_landing">GeoIP2</a> databases，有database type限制。</li>
</ul>
<p>我们使用的是第三方的ip库，只能通过maxminddb-golang解析数据，根据业务场景封装自己的api，具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Enterprise <span class="keyword">struct</span> &#123;</span><br><span class="line">   City <span class="keyword">struct</span> &#123;</span><br><span class="line">      Names <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`maxminddb:&quot;names&quot;`</span></span><br><span class="line">   &#125; <span class="string">`maxminddb:&quot;city&quot;`</span></span><br><span class="line">   Continent <span class="keyword">struct</span> &#123;</span><br><span class="line">      Code  <span class="keyword">string</span>            <span class="string">`maxminddb:&quot;code&quot;`</span></span><br><span class="line">      Names <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`maxminddb:&quot;names&quot;`</span></span><br><span class="line">   &#125; <span class="string">`maxminddb:&quot;continent&quot;`</span></span><br><span class="line">   Country <span class="keyword">struct</span> &#123;</span><br><span class="line">      IsoCode <span class="keyword">string</span>            <span class="string">`maxminddb:&quot;iso_code&quot;`</span></span><br><span class="line">      Names   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`maxminddb:&quot;names&quot;`</span></span><br><span class="line">   &#125; <span class="string">`maxminddb:&quot;country&quot;`</span></span><br><span class="line">   ISP <span class="keyword">struct</span> &#123;</span><br><span class="line">      Names <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`maxminddb:&quot;names&quot;`</span></span><br><span class="line">   &#125; <span class="string">`maxminddb:&quot;isp&quot;`</span></span><br><span class="line">   Location <span class="keyword">struct</span> &#123;</span><br><span class="line">      Latitude  <span class="keyword">float64</span> <span class="string">`maxminddb:&quot;latitude&quot;`</span></span><br><span class="line">      Longitude <span class="keyword">float64</span> <span class="string">`maxminddb:&quot;longitude&quot;`</span></span><br><span class="line">   &#125; <span class="string">`maxminddb:&quot;location&quot;`</span></span><br><span class="line">   Province <span class="keyword">struct</span> &#123;</span><br><span class="line">      IsoCode <span class="keyword">string</span>            <span class="string">`maxminddb:&quot;iso_code&quot;`</span></span><br><span class="line">      Names   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`maxminddb:&quot;names&quot;`</span></span><br><span class="line">   &#125; <span class="string">`maxminddb:&quot;province&quot;`</span></span><br><span class="line">   Subdivisions []<span class="keyword">struct</span> &#123;</span><br><span class="line">      IsoCode <span class="keyword">string</span>            <span class="string">`maxminddb:&quot;iso_code&quot;`</span></span><br><span class="line">      Names   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`maxminddb:&quot;names&quot;`</span></span><br><span class="line">   &#125; <span class="string">`maxminddb:&quot;subdivisions&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file = ipip.mmdb</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGeoIp2</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="params">(d *maxminddb.Reader, f <span class="keyword">func</span>()</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">	 <span class="comment">//打开.mmdb文件</span></span><br><span class="line">   d, err = maxminddb.Open(file)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//程序结束关闭函数 闭包</span></span><br><span class="line">   f = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">         _ = d.Close()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> d, f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GeoIpRepo <span class="keyword">struct</span> &#123;</span><br><span class="line">   ipDb *maxminddb.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGeoIpRepo</span><span class="params">(data *maxminddb.Reader)</span> *<span class="title">GeoIpRepo</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;GeoIpRepo&#123;</span><br><span class="line">      ipDb: data,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GeoIP <span class="keyword">struct</span> &#123;</span><br><span class="line">	Country  <span class="keyword">string</span></span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">	City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GeoIpRepo)</span> <span class="title">GetIpLocation</span><span class="params">(ctx context.Context, ip <span class="keyword">string</span>)</span> <span class="params">(r GeoIP, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">//解析ip</span></span><br><span class="line">  ipV := net.ParseIP(ip)</span><br><span class="line">  <span class="comment">//如果不能确定mmdb结构 可以使用map去接收数据 然后再定义结构体</span></span><br><span class="line">  <span class="comment">//var record =make(map[string]interface&#123;&#125;)</span></span><br><span class="line">   <span class="keyword">var</span> record = Enterprise&#123;&#125;</span><br><span class="line">  <span class="comment">//二分查找数据</span></span><br><span class="line">   err = g.ipDb.Lookup(ipV, &amp;record)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Warnf(<span class="string">&quot;ip %s get location failed,%v&quot;</span>, ip, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//转换</span></span><br><span class="line">   <span class="keyword">if</span> c, ok := record.Country.Names[<span class="string">&quot;zh-CN&quot;</span>]; ok &#123;</span><br><span class="line">      r.Country = c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> c, ok := record.City.Names[<span class="string">&quot;zh-CN&quot;</span>]; ok &#123;</span><br><span class="line">      r.City = c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> c, ok := record.Province.Names[<span class="string">&quot;zh-CN&quot;</span>]; ok &#123;</span><br><span class="line">      r.Province = c</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>go实现动态鉴权</title>
    <url>/2021/10/15/go%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go开发</tag>
      </tags>
  </entry>
  <entry>
    <title>go参数校验</title>
    <url>/2021/12/15/go%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>go常用 <a href="https://github.com/go-playground/validator">validator</a> 进行字段参数校验，其内置了很多常用的字段参数校验方法，同时支持注册自定义方案。v10版本有支持验证结果的国际化。内置的验证tag翻阅文档：<a href="https://github.com/go-playground/validator/blob/master/README.md">内置tag</a> </p>
<span id="more"></span>

<h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><p>注册器初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> validator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-playground/locales/en&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-playground/locales/zh&quot;</span></span><br><span class="line">	ut <span class="string">&quot;github.com/go-playground/universal-translator&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line">	en_translations <span class="string">&quot;github.com/go-playground/validator/v10/translations/en&quot;</span></span><br><span class="line">	zh_translations <span class="string">&quot;github.com/go-playground/validator/v10/translations/zh&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	valid            *validator.Validate</span><br><span class="line">	uni              *ut.UniversalTranslator</span><br><span class="line">	enTrans, zhTrans ut.Translator</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> found <span class="keyword">bool</span></span><br><span class="line">	valid = validator.New() <span class="comment">//验证器初始化</span></span><br><span class="line">	ent := en.New()</span><br><span class="line">	uni = ut.New(ent, ent)</span><br><span class="line">	enTrans, found = uni.GetTranslator(<span class="string">&quot;en&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> !found &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;en translation not found&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	zht := zh.New()</span><br><span class="line">	uni = ut.New(zht, zht)</span><br><span class="line">	zhTrans, found = uni.GetTranslator(<span class="string">&quot;zh&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> !found &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;zh translation not found&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注册英文翻译</span></span><br><span class="line">	err := en_translations.RegisterDefaultTranslations(valid, enTrans)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注册中文翻译</span></span><br><span class="line">	err = zh_translations.RegisterDefaultTranslations(valid, zhTrans)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//自定义校验函数</span></span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>验证方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ValidateStructData 验证方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateStructData</span><span class="params">(l <span class="keyword">string</span>, dataStruct <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   trans := enTrans</span><br><span class="line">   <span class="comment">//前端传的字段 通过tag json获取</span></span><br><span class="line">   valid.RegisterTagNameFunc(<span class="function"><span class="keyword">func</span><span class="params">(fld reflect.StructField)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">      name := strings.SplitN(fld.Tag.Get(<span class="string">&quot;json&quot;</span>), <span class="string">&quot;,&quot;</span>, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">if</span> name == <span class="string">&quot;-&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">if</span> l == <span class="string">&quot;zh&quot;</span> &#123;</span><br><span class="line">      trans = zhTrans</span><br><span class="line">      <span class="comment">// 中文需要字段国际化 注册字段标签</span></span><br><span class="line">      valid.RegisterTagNameFunc(<span class="function"><span class="keyword">func</span><span class="params">(fld reflect.StructField)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">         name := fld.Tag.Get(<span class="string">&quot;label&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span> name</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   err := valid.Struct(dataStruct)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> errs, ok := err.(validator.ValidationErrors); ok &#123;</span><br><span class="line">         <span class="keyword">for</span> _, fe := <span class="keyword">range</span> errs &#123;</span><br><span class="line">            errStr := fe.Translate(trans)</span><br><span class="line">            <span class="comment">//可以根据平台的业务错误码进行封装业务错误</span></span><br><span class="line">            fmt.Println(errStr)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//验证单个字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateVarData</span><span class="params">(f <span class="keyword">interface</span>&#123;&#125;, tag, filed <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	trans := enTrans</span><br><span class="line">	err := valid.Var(f, tag)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errs, ok := err.(validator.ValidationErrors); ok &#123;</span><br><span class="line">			<span class="keyword">for</span> _, fe := <span class="keyword">range</span> errs &#123;</span><br><span class="line">				errStr := fe.Translate(trans)</span><br><span class="line">				<span class="comment">//可以根据平台的业务错误码进行封装业务错误</span></span><br><span class="line">				fmt.Println(filed, errStr)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestValidateData</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> testStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name      <span class="keyword">string</span> <span class="string">`json:&quot;name&quot; validate:&quot;required&quot; label:&quot;函数名&quot;`</span></span><br><span class="line">		StartTime <span class="keyword">int</span>    <span class="string">`json:&quot;start_time&quot; validate:&quot;required,gt=0&quot; label:&quot;开始时间&quot;`</span></span><br><span class="line">		EndTime   <span class="keyword">int</span>    <span class="string">`json:&quot;end_time&quot;`</span></span><br><span class="line">		Interval  <span class="keyword">string</span> <span class="string">`json:&quot;interval&quot; validate:&quot;required&quot; label:&quot;时间间隔&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line">	d:=testStruct&#123;</span><br><span class="line">		Name: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	err := ValidateStructData(<span class="string">&quot;en&quot;</span>, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过字段tag自定义函数"><a href="#通过字段tag自定义函数" class="headerlink" title="通过字段tag自定义函数"></a>通过字段tag自定义函数</h3>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>go国际化实现</title>
    <url>/2021/09/15/go%E5%AE%9E%E7%8E%B0%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>go协程池实现</title>
    <url>/2021/12/15/go%E5%8D%8F%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>go查询Elastic</title>
    <url>/2021/07/16/go%E6%9F%A5%E8%AF%A2Elastic/</url>
    <content><![CDATA[<p>go操作elasticsearch有两个常用的库：</p>
<ul>
<li>github.com/elastic/go-elasticsearch 官方提供的操作库</li>
<li>github.com/olivere/elastic 第三方包，封装了更多的高级api</li>
</ul>
<p>两个库都可以使用，出于我们操作场景不复杂，用来查询数据，我们使用官方库封装了一个api，:(官方库说是性能比较好</p>
<span id="more"></span>

<h3 id="初始化客户端"><a href="#初始化客户端" class="headerlink" title="初始化客户端"></a>初始化客户端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	es <span class="string">&quot;github.com/elastic/go-elasticsearch/v7&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/tidwall/gjson&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// Elastic 基于官方库封装</span></span><br><span class="line"><span class="keyword">type</span> Elastic <span class="keyword">struct</span> &#123;</span><br><span class="line">   es  *es.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// M+A构建复杂的查询条件</span></span><br><span class="line"><span class="keyword">type</span> M = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> A = []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewElasticClient</span><span class="params">(conf *conf.Data, logger log.Logger)</span> <span class="params">(*Elastic, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> err error</span><br><span class="line">   client, err := es.NewClient(es.Config&#123;</span><br><span class="line">      Addresses: conf.Es.Clusters, <span class="comment">//es集群 支持多个host</span></span><br><span class="line">      Username:  conf.Es.User, <span class="comment">//用户名</span></span><br><span class="line">      Password:  conf.Es.Password, <span class="comment">//密码</span></span><br><span class="line">   &#125;)</span><br><span class="line">   ctx, cancel := context.WithTimeout(context.Background(), <span class="number">30</span>*time.Second)</span><br><span class="line">   <span class="keyword">defer</span> cancel()</span><br><span class="line">  <span class="comment">//es信息</span></span><br><span class="line">   res, err := client.Info(client.Info.WithContext(ctx))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">   <span class="keyword">if</span> res.IsError() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   b, err := ioutil.ReadAll(res.Body)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   	fmt.Println(<span class="string">&quot;es version: &quot;</span>, gjson.ParseBytes(b).Get(<span class="string">&quot;version.number&quot;</span>).String())</span><br><span class="line">   <span class="keyword">return</span> &amp;Elastic&#123;</span><br><span class="line">      es:  client,</span><br><span class="line">      log: l,</span><br><span class="line">   &#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装API"><a href="#封装API" class="headerlink" title="封装API"></a>封装API</h3><p>查询函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Elastic)</span> <span class="title">Search</span><span class="params">(ctx context.Context, index []<span class="keyword">string</span>, query M)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">   <span class="keyword">if</span> err := json.NewEncoder(&amp;buf).Encode(query); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// b, _ := json.MarshalIndent(query, &quot; &quot;, &quot; &quot;)</span></span><br><span class="line">   <span class="comment">//fmt.Println(string(b))</span></span><br><span class="line">   res, err := c.es.Search(</span><br><span class="line">      c.es.Search.WithContext(ctx),</span><br><span class="line">      c.es.Search.WithIndex(index...),</span><br><span class="line">      c.es.Search.WithBody(&amp;buf),</span><br><span class="line">      c.es.Search.WithTrackTotalHits(<span class="literal">true</span>),</span><br><span class="line">      c.es.Search.WithPretty(),</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">   <span class="keyword">if</span> res.IsError() &#123;</span><br><span class="line">      <span class="keyword">var</span> e <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;e); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;error parsing the response body: %s&quot;</span>, err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         errB, _ := json.Marshal(e)</span><br><span class="line">         fmt.Println(<span class="keyword">string</span>(errB))</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;[%s] %s: %s&quot;</span>, res.Status(), e[<span class="string">&quot;error&quot;</span>].(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;type&quot;</span>],</span><br><span class="line">            e[<span class="string">&quot;error&quot;</span>].(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;reason&quot;</span>])</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      b, err := ioutil.ReadAll(res.Body)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewEsClientOld</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   info, err := NewElasticClient(&amp;conf.Data&#123;</span><br><span class="line">      Es: &amp;conf.ES&#123;</span><br><span class="line">         Clusters: []<span class="keyword">string</span>&#123;<span class="string">&quot;xxxxx&quot;</span>&#125;,</span><br><span class="line">         User:     <span class="string">&quot;xxxxx&quot;</span>,</span><br><span class="line">         Password: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;, l)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      t.Log(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> query = M&#123;</span><br><span class="line">      <span class="string">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;from&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;sort&quot;</span>: A&#123;</span><br><span class="line">         M&#123;<span class="string">&quot;timestamp&quot;</span>: M&#123;<span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span>&#125;&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;query&quot;</span>: M&#123;</span><br><span class="line">         <span class="string">&quot;bool&quot;</span>: M&#123;</span><br><span class="line">            <span class="string">&quot;filter&quot;</span>: M&#123;</span><br><span class="line">               <span class="string">&quot;bool&quot;</span>: M&#123;</span><br><span class="line">                  <span class="string">&quot;must&quot;</span>: A&#123;</span><br><span class="line">                     M&#123;<span class="string">&quot;term&quot;</span>: M&#123;<span class="string">&quot;xxx&quot;</span>: <span class="string">&quot;407904ce-c279-1d0e-fbeb-d12ccfafa827&quot;</span>&#125;&#125;,</span><br><span class="line">                     M&#123;<span class="string">&quot;term&quot;</span>: M&#123;<span class="string">&quot;xxx&quot;</span>: <span class="string">&quot;775e6349-dbd2-6d8e-6b9c-58818f770574&quot;</span>&#125;&#125;,</span><br><span class="line">                     M&#123;<span class="string">&quot;range&quot;</span>: M&#123;<span class="string">&quot;timestamp&quot;</span>: M&#123;</span><br><span class="line">                        <span class="string">&quot;gte&quot;</span>: time.Now().AddDate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">                        <span class="string">&quot;lte&quot;</span>: time.Now(),</span><br><span class="line">                     &#125;&#125;&#125;,</span><br><span class="line">                  &#125;,</span><br><span class="line">               &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">         &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   search, err := info.Search(context.Background(),[]<span class="keyword">string</span>&#123;<span class="string">&quot;xxxx&quot;</span>&#125;,query)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(search)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>go依赖注入</title>
    <url>/2021/12/23/go%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>Go的依赖注入框架有两类，一类是通过反射在运行时进行依赖注入，典型代表是 uber 开源的 dig，另外一类是通过 generate 进行代码生成，典型代表是 Google 开源的 wire。使用 dig 功能会强大一些，但是缺点就是错误只能在运行时才能发现，这样如果不小心的话可能会导致一些隐藏的 bug 出现。使用 wire 的缺点就是功能限制多一些，但是好处就是编译的时候就可以发现问题，并且生成的代码其实和我们自己手写相关代码差不太多。实际项目中我们使用wire实现依赖注入。</p>
<span id="more"></span>

<h2 id="wire"><a href="#wire" class="headerlink" title="wire"></a>wire</h2><p>wire有两个基础概念，构造器provider和injector注入器：</p>
<ul>
<li>Provider：是一个普通的函数，这个函数会返回构建依赖关系所需的组件。相当于实例化一个对象。</li>
<li>injector：也是一个普通函数，我们常常在 <code>wire.go</code> 文件中定义 injector 函数签名，然后通过 <code>wire</code> 命令自动生成一个完整的函数。</li>
</ul>
<h3 id="provider构造器"><a href="#provider构造器" class="headerlink" title="provider构造器"></a>provider构造器</h3><p>provider函数，一般跟着结构体对象定义，<strong>在 wire 中不能存在两个 provider 返回相同的组件类型</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserService</span><span class="params">()</span> *<span class="title">UserService</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;UserService&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在wire_set.go设置provider set：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/102er/apiserver/internal/service&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/wire&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ProviderSet = wire.NewSet(service.NewUserService)</span><br></pre></td></tr></table></figure>

<p>我们可以使用<strong>ProviderSet</strong>，它主要把provider打包成一个集合，我们传给injector只需要传这个集合即可，这样方便我们维护provide。当然，也可以直接把NewUserService()这个函数传给injector的build函数</p>
<h3 id="injector注入器"><a href="#injector注入器" class="headerlink" title="injector注入器"></a>injector注入器</h3><p>injector函数一般定义在wire.go文件中，通过wire命令自动生成一个完整的函数，wire.go代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:build wireinject</span></span><br><span class="line"><span class="comment">// +build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The build tag makes sure the stub is not built in the final build.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/102er/apiserver/internal&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/102er/apiserver/internal/server&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/google/wire&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，且会返回一个gin的engine </span></span><br><span class="line"><span class="comment">//main函数可以调用initApi 拿到 gin.engine 启动服</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initApi</span><span class="params">()</span> <span class="params">(*gin.Engine, error)</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(wire.Build(internal.ProviderSet, server.NewGinHttpServer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>//+build wireinject<code>与</code>package main`这两行之间的空行必须要有。</li>
<li><code>+build</code>其实是 Go 语言的一个特性。类似 C/C++ 的条件编译，在执行<code>go build</code>时可传入一些选项，根据这个选项决定某些文件是否编译。<code>//+build wireinject</code> 注释确保了这个文件在我们正常编译的时候不会被引用。</li>
<li><code>wire</code>工具只会处理有<code>wireinject</code>的文件，所以我们的<code>wire.go</code>文件要加上这个。</li>
</ul>
<p>上面的代码通过 wire 工具生成：wire_gen.go代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate go run github.com/google/wire/cmd/wire</span></span><br><span class="line"><span class="comment">//go:build !wireinject</span></span><br><span class="line"><span class="comment">// +build !wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/102er/apiserver/internal/server&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/102er/apiserver/internal/service&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Injectors from wire.go:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initApi</span><span class="params">()</span> <span class="params">(*gin.Engine, error)</span></span> &#123;</span><br><span class="line">   userService := service.NewUserService()</span><br><span class="line">   engine := server.NewGinHttpServer(userService)</span><br><span class="line">   <span class="keyword">return</span> engine, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码示例参数：<a href="https://github.com/102er/apiserver">102er-apiserver</a></p>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h4 id="不要使用默认类型"><a href="#不要使用默认类型" class="headerlink" title="不要使用默认类型"></a>不要使用默认类型</h4><p>wire 不支持两个提供<strong>两个相同类型</strong>的 provider，所以如果我们使用默认类型如 <code>int</code> <code>string</code> 等，只要有两个依赖就会导致报错，解决方案是使用类型别名。</p>
<h4 id="Option-Struct"><a href="#Option-Struct" class="headerlink" title="Option Struct"></a>Option Struct</h4><p>某个provide函数可能会有很多参数，这时候可以定义option struct，使用 <code>wire.Strcut</code> 来构建 Option Strcut 的依赖</p>
<h4 id="返回错误"><a href="#返回错误" class="headerlink" title="返回错误"></a>返回错误</h4><p>在 go 中如果遇到错误，我们会在最后一个返回值返回 error，wire 同样也支持返回错误的情况，只需要在 injector 的函数签名中加上 error 返回值即可</p>
<h4 id="清理函数"><a href="#清理函数" class="headerlink" title="清理函数"></a>清理函数</h4><p>通常打开文件或者是链接这种需要关闭的资源，这时候 provider 可以返回一个闭包函数 <code>func()</code> ，wire 在进行构建的时候，会在报错的时候调用，并且会将所有的<strong>闭包</strong>函数聚合返回。</p>
]]></content>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列介绍</title>
    <url>/2020/06/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>​        消息队列是一种异步的服务间通信方式，适用于无服务器和微服务架构。消息在被处理和删除之前一直存储在队列上。每条消息仅可被一位用户处理一次。消息队列可被用于分离重量级处理、缓冲或批处理工作以及缓解高峰期工作负载。常见的消息队列：rabbitMQ，pulsar，kafka，redis，ActiveMQ…</p>
<h3 id="rabbitMQ"><a href="#rabbitMQ" class="headerlink" title="rabbitMQ"></a>rabbitMQ</h3><h2 id="pulsar"><a href="#pulsar" class="headerlink" title="pulsar"></a>pulsar</h2><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2>]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
</search>
